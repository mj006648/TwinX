# apps/rook-ceph-resources/storageclass.yaml

# 1. 블록 스토리지 클래스
apiVersion: storage.k8s.io/v1
kind: StorageClass
metadata:
  name: rook-ceph-block
  annotations:
    storageclass.kubernetes.io/is-default-class: "true"
provisioner: rook-ceph.rbd.csi.ceph.com
parameters:
  clusterID: rook-ceph
  pool: replicapool
  imageFormat: "2"
  imageFeatures: layering
  "csi.storage.k8s.io/provisioner-secret-name": rook-csi-rbd-provisioner
  "csi.storage.k8s.io/provisioner-secret-namespace": rook-ceph
  "csi.storage.k8s.io/node-stage-secret-name": rook-csi-rbd-node
  "csi.storage.k8s.io/node-stage-secret-namespace": rook-ceph
  "csi.storage.k8s.io/fstype": ext4
reclaimPolicy: Delete
allowVolumeExpansion: true
---
# 2. 파일 스토리지 클래스
apiVersion: storage.k8s.io/v1
kind: StorageClass
metadata:
  name: rook-ceph-fs
provisioner: rook-ceph.cephfs.csi.ceph.com
parameters:
  clusterID: rook-ceph
  fsName: myfs
  # 'replicated'를 정확하게 가리키도록
  pool: replicated
  "csi.storage.k8s.io/provisioner-secret-name": rook-csi-cephfs-provisioner
  "csi.storage.k8s.io/provisioner-secret-namespace": rook-ceph
  "csi.storage.k8s.io/node-stage-secret-name": rook-csi-cephfs-node
  "csi.storage.k8s.io/node-stage-secret-namespace": rook-ceph
reclaimPolicy: Delete
allowVolumeExpansion: true
---
# 3. 객체 스토리지 클래스
apiVersion: storage.k8s.io/v1
kind: StorageClass
metadata:
  name: rook-ceph-bucket
provisioner: rook-ceph.ceph.rook.io/bucket # OBC 프로비저너를 지정합니다.
reclaimPolicy: Delete # OBC가 삭제되면 실제 버킷도 삭제되도록 설정합니다.
parameters:
  # 1단계에서 만든 CephObjectStore의 이름을 정확히 지정합니다.
  objectStoreName: my-store
  # CephObjectStore가 존재하는 네임스페이스를 지정합니다.
  objectStoreNamespace: rook-ceph
